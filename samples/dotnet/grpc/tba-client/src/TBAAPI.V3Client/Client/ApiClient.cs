/* 
 * The Blue Alliance API v3
 *
 * # Overview    Information and statistics about FIRST Robotics Competition teams and events.   # Authentication   All endpoints require an Auth Key to be passed in the header `X-TBA-Auth-Key`. If you do not have an auth key yet, you can obtain one from your [Account Page](/account).    A `User-Agent` header may need to be set to prevent a 403 Unauthorized error.
 *
 * The version of the OpenAPI document: 3.8.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

namespace TBAAPI.V3Client.Client;

using System;
using System.Collections.Generic;
using System.IO;
using System.Net;

using RestSharp;
using RestSharp.Deserializers;
/// <summary>
/// Provides a default implementation of an Api client (both synchronous and asynchronous implementatios),
/// encapsulating general REST accessor use cases.
/// </summary>
public partial class ApiClient : ISynchronousClient, IAsynchronousClient
{
    private readonly string _baseUrl;

    /// <summary>
    /// Allows for extending request processing for <see cref="ApiClient"/> generated code.
    /// </summary>
    /// <param name="request">The RestSharp request object</param>
    partial void InterceptRequest(IRestRequest request);

    /// <summary>
    /// Allows for extending response processing for <see cref="ApiClient"/> generated code.
    /// </summary>
    /// <param name="request">The RestSharp request object</param>
    /// <param name="response">The RestSharp response object</param>
    partial void InterceptResponse(IRestRequest request, IRestResponse response);

    /// <summary>
    /// Initializes a new instance of the <see cref="ApiClient" />, defaulting to the global configurations' base url.
    /// </summary>
    public ApiClient() => _baseUrl = GlobalConfiguration.Instance.BasePath;

    /// <summary>
    /// Initializes a new instance of the <see cref="ApiClient" />
    /// </summary>
    /// <param name="basePath">The target service's base path in URL format.</param>
    /// <exception cref="ArgumentException"></exception>
    public ApiClient(string basePath)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(basePath);

        _baseUrl = basePath;
    }

    /// <summary>
    /// Constructs the RestSharp version of an http method
    /// </summary>
    /// <param name="method">Swagger Client Custom HttpMethod</param>
    /// <returns>RestSharp's HttpMethod instance.</returns>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    private static Method Method(HttpMethod method)
    {
        Method other = method switch
        {
            HttpMethod.Get => RestSharp.Method.GET,
            HttpMethod.Post => RestSharp.Method.POST,
            HttpMethod.Put => RestSharp.Method.PUT,
            HttpMethod.Delete => RestSharp.Method.DELETE,
            HttpMethod.Head => RestSharp.Method.HEAD,
            HttpMethod.Options => RestSharp.Method.OPTIONS,
            HttpMethod.Patch => RestSharp.Method.PATCH,
            _ => throw new ArgumentOutOfRangeException(nameof(method), method, null),
        };
        return other;
    }

    /// <summary>
    /// Provides all logic for constructing a new RestSharp <see cref="RestRequest"/>.
    /// At this point, all information for querying the service is known. Here, it is simply
    /// mapped into the RestSharp request.
    /// </summary>
    /// <param name="method">The http verb.</param>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>[private] A new RestRequest instance.</returns>
    /// <exception cref="ArgumentNullException"></exception>
    private static RestRequest NewRequest(
        HttpMethod method,
        string path,
        RequestOptions options,
        IReadableConfiguration configuration)
    {
        ArgumentNullException.ThrowIfNull(path);
        ArgumentNullException.ThrowIfNull(options);
        ArgumentNullException.ThrowIfNull(configuration);

        RestRequest request = new(Method(method))
        {
            Resource = path,
            JsonSerializer = new CustomJsonCodec(configuration)
        };

        if (options.PathParameters is not null)
        {
            foreach (KeyValuePair<string, string> pathParam in options.PathParameters)
            {
                request.AddParameter(pathParam.Key, pathParam.Value, ParameterType.UrlSegment);
            }
        }

        if (options.QueryParameters is not null)
        {
            foreach (KeyValuePair<string, IList<string>> queryParam in options.QueryParameters)
            {
                foreach (var value in queryParam.Value)
                {
                    request.AddQueryParameter(queryParam.Key, value);
                }
            }
        }

        if (configuration.DefaultHeaders is not null)
        {
            foreach (KeyValuePair<string, string> headerParam in configuration.DefaultHeaders)
            {
                request.AddHeader(headerParam.Key, headerParam.Value);
            }
        }

        if (options.HeaderParameters is not null)
        {
            foreach (KeyValuePair<string, IList<string>> headerParam in options.HeaderParameters)
            {
                foreach (var value in headerParam.Value)
                {
                    request.AddHeader(headerParam.Key, value);
                }
            }
        }

        if (options.FormParameters is not null)
        {
            foreach (KeyValuePair<string, string> formParam in options.FormParameters)
            {
                request.AddParameter(formParam.Key, formParam.Value);
            }
        }

        if (options.Data is not null)
        {
            if (options.HeaderParameters is not null)
            {
                IList<string> contentTypes = options.HeaderParameters["Content-Type"];
                if (contentTypes is null || contentTypes.Any(header => header.Contains("application/json")))
                {
                    request.RequestFormat = DataFormat.Json;
                }
                else
                {
                    // TODO: Generated client user should add additional handlers. RestSharp only supports XML and JSON, with XML as default.
                }
            }
            else
            {
                // Here, we'll assume JSON APIs are more common. XML can be forced by adding produces/consumes to openapi spec explicitly.
                request.RequestFormat = DataFormat.Json;
            }

            request.AddJsonBody(options.Data);
        }

        if (options.FileParameters is not null)
        {
            foreach (KeyValuePair<string, Stream> fileParam in options.FileParameters)
            {
                var bytes = ClientUtils.ReadAsBytes(fileParam.Value);
                if (fileParam.Value is FileStream fileStream)
                {
                    request.Files.Add(FileParameter.Create(fileParam.Key, bytes, Path.GetFileName(fileStream.Name)));
                }
                else
                {
                    request.Files.Add(FileParameter.Create(fileParam.Key, bytes, "no_file_name_provided"));
                }
            }
        }

        if (options.Cookies is not null && options.Cookies.Count > 0)
        {
            foreach (Cookie cookie in options.Cookies)
            {
                request.AddCookie(cookie.Name, cookie.Value);
            }
        }

        return request;
    }

    private static ApiResponse<T> ToApiResponse<T>(IRestResponse<T> response)
    {
        T result = response.Data;
        var rawContent = response.Content;

        var transformed = new ApiResponse<T>(response.StatusCode, [], result, rawContent)
        {
            ErrorText = response.ErrorMessage ?? (!response.IsSuccessful ? rawContent : null),
            Cookies = []
        };

        if (response.Headers is not null)
        {
            foreach (Parameter responseHeader in response.Headers)
            {
                transformed.Headers.Add(responseHeader.Name!, ClientUtils.ParameterToString(responseHeader.Value!));
            }
        }

        if (response.Cookies is not null)
        {
            foreach (RestResponseCookie responseCookies in response.Cookies)
            {
                transformed.Cookies.Add(
                    new Cookie(
                        responseCookies.Name,
                        responseCookies.Value,
                        responseCookies.Path,
                        responseCookies.Domain)
                    );
            }
        }

        return transformed;
    }

    private ApiResponse<T> Exec<T>(RestRequest req, IReadableConfiguration configuration)
    {
        RestClient client = new(_baseUrl);

        client.ClearHandlers();
        var existingDeserializer = req.JsonSerializer as IDeserializer;
        if (existingDeserializer is not null)
        {
            IDeserializer factory() => existingDeserializer;
            client.AddHandler("application/json", factory);
            client.AddHandler("text/json", factory);
            client.AddHandler("text/x-json", factory);
            client.AddHandler("text/javascript", factory);
            client.AddHandler("*+json", factory);
        }
        else
        {
            var customCodec = new CustomJsonCodec(configuration);
            IDeserializer factory() => customCodec;
            client.AddHandler("application/json", factory);
            client.AddHandler("text/json", factory);
            client.AddHandler("text/x-json", factory);
            client.AddHandler("text/javascript", factory);
            client.AddHandler("*+json", factory);
        }

        var xmlSerializerInstance = new XmlDeserializer();
        IDeserializer xmlDeserializerFactory() => xmlSerializerInstance;
        client.AddHandler("application/xml", xmlDeserializerFactory);
        client.AddHandler("text/xml", xmlDeserializerFactory);
        client.AddHandler("*+xml", xmlDeserializerFactory);
        client.AddHandler("*", xmlDeserializerFactory);

        client.Timeout = configuration.Timeout;

        if (configuration.UserAgent is not null)
        {
            client.UserAgent = configuration.UserAgent;
        }

        if (configuration.ClientCertificates is not null)
        {
            client.ClientCertificates = configuration.ClientCertificates;
        }

        InterceptRequest(req);

        IRestResponse<T> response = client.Execute<T>(req);

        InterceptResponse(req, response);

        ApiResponse<T> result = ToApiResponse(response);
        if (response.ErrorMessage is not null)
        {
            result.ErrorText = response.ErrorMessage;
        }

        if (response.Cookies is not null && response.Cookies.Count > 0)
        {
            result.Cookies ??= [];

            foreach (RestResponseCookie restResponseCookie in response.Cookies)
            {
                var cookie = new Cookie(
                    restResponseCookie.Name,
                    restResponseCookie.Value,
                    restResponseCookie.Path,
                    restResponseCookie.Domain
                )
                {
                    Comment = restResponseCookie.Comment,
                    CommentUri = restResponseCookie.CommentUri,
                    Discard = restResponseCookie.Discard,
                    Expired = restResponseCookie.Expired,
                    Expires = restResponseCookie.Expires,
                    HttpOnly = restResponseCookie.HttpOnly,
                    Port = restResponseCookie.Port,
                    Secure = restResponseCookie.Secure,
                    Version = restResponseCookie.Version
                };

                result.Cookies.Add(cookie);
            }
        }

        return result;
    }

    private async Task<ApiResponse<T>> ExecAsync<T>(RestRequest req, IReadableConfiguration configuration)
    {
        RestClient client = new(_baseUrl);

        client.ClearHandlers();
        if (req.JsonSerializer is IDeserializer existingDeserializer)
        {
            IDeserializer factory() => existingDeserializer;
            client.AddHandler("application/json", factory);
            client.AddHandler("text/json", factory);
            client.AddHandler("text/x-json", factory);
            client.AddHandler("text/javascript", factory);
            client.AddHandler("*+json", factory);
        }
        else
        {
            var customCodec = new CustomJsonCodec(configuration);
            IDeserializer factory() => customCodec;
            client.AddHandler("application/json", factory);
            client.AddHandler("text/json", factory);
            client.AddHandler("text/x-json", factory);
            client.AddHandler("text/javascript", factory);
            client.AddHandler("*+json", factory);
        }

        var xmlSerializerInstance = new XmlDeserializer();
        IDeserializer xmlDeserializerFactory() => xmlSerializerInstance;
        client.AddHandler("application/xml", xmlDeserializerFactory);
        client.AddHandler("text/xml", xmlDeserializerFactory);
        client.AddHandler("*+xml", xmlDeserializerFactory);
        client.AddHandler("*", xmlDeserializerFactory);

        client.Timeout = configuration.Timeout;

        if (configuration.UserAgent is not null)
        {
            client.UserAgent = configuration.UserAgent;
        }

        if (configuration.ClientCertificates is not null)
        {
            client.ClientCertificates = configuration.ClientCertificates;
        }

        InterceptRequest(req);

        IRestResponse<T> response = await client.ExecuteAsync<T>(req);

        InterceptResponse(req, response);

        ApiResponse<T> result = ToApiResponse(response);
        if (response.ErrorMessage is not null)
        {
            result.ErrorText = response.ErrorMessage;
        }

        if (response.Cookies is not null && response.Cookies.Count > 0)
        {
            result.Cookies ??= [];

            foreach (RestResponseCookie restResponseCookie in response.Cookies)
            {
                var cookie = new Cookie(
                    restResponseCookie.Name,
                    restResponseCookie.Value,
                    restResponseCookie.Path,
                    restResponseCookie.Domain
                )
                {
                    Comment = restResponseCookie.Comment,
                    CommentUri = restResponseCookie.CommentUri,
                    Discard = restResponseCookie.Discard,
                    Expired = restResponseCookie.Expired,
                    Expires = restResponseCookie.Expires,
                    HttpOnly = restResponseCookie.HttpOnly,
                    Port = restResponseCookie.Port,
                    Secure = restResponseCookie.Secure,
                    Version = restResponseCookie.Version
                };

                result.Cookies.Add(cookie);
            }
        }

        return result;
    }

    #region IAsynchronousClient
    /// <summary>
    /// Make a HTTP GET request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> GetAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Get, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP POST request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PostAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Post, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP PUT request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PutAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Put, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP DELETE request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> DeleteAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Delete, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP HEAD request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> HeadAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Head, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP OPTION request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> OptionsAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Options, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP PATCH request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PatchAsync<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Patch, path, options, config), config);
    }
    #endregion IAsynchronousClient

    #region ISynchronousClient
    /// <summary>
    /// Make a HTTP GET request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Get<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Get, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP POST request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Post<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Post, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP PUT request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Put<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Put, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP DELETE request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Delete<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Delete, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP HEAD request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Head<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Head, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP OPTION request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Options<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Options, path, options, config), config);
    }

    /// <summary>
    /// Make a HTTP PATCH request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Patch<T>(string path, RequestOptions options, IReadableConfiguration? configuration = null)
    {
        IReadableConfiguration config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Patch, path, options, config), config);
    }
    #endregion ISynchronousClient
}
